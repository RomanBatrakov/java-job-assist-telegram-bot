[
  {
    "question": "Что такое ООП?",
    "answer": "ООП - методология программирования, основанная на представлении программного продукта в виде совокупности объектов, каждый из которых является экземпляром конкретного класса. \nООП использует в качестве базовых элементов взаимодействие объектов.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое объект?",
    "answer": "Объект - именнованная модель реальной сущности, обладающая конкретными значениями свойств и проявляющая свое поведение, обладающий именем набор данных (полей и свойств объекта), физически находящихся в памяти компьютера, и методов, имеющих доступ к ним. \nОбъект - конкретный экземпляр класса.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Назовите основные принципы ООП.",
    "answer": "1.Абстракция \n2.Инкапсуляция \n3.Наследование \n4.Полиморфизм",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое наследование?",
    "answer": "Наследование - это процесс благодаря которому один объект может приобрести свойства другого объекта и добавлять черты характерные только для него самого.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое полиморфизм?",
    "answer": "Полиморфизм - это способность программы одинаково работать с объектами, если они имеют одинаковый интерфейс.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие существуют виды полиморфизма?",
    "answer": "1.Классический - если разные классы имплементируют одинаковый интерфейс или наследуются от одного класса, их объекты будут вести себя одинаково. \n2.Ad-hoc: а)Динамический - переопределение методов; б)Статический - перегрузка методов. \n3.Параметрический — реализация поведения класса или метода с указанием параметров и возвращаемых значений общего вида вместо конкретных.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое инкапсуляция?",
    "answer": "Инкапсуляция - это сокрытие реализации класса и отделение его внутреннего представления от внешнего (интерфейса). \nЭто свойство которое позволяет закрыть доступ к полям и методам класса другим классам, а предоставлять им доступ только через интерфейс(метод)",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое aбстракция?",
    "answer": "Абстракция - это принцип, при котором пользователю класса доступны только методы, описывающие основное поведение, а остальные детали скрыты внутри реализации.",
    "category": "JAVA_CORE"
  },
  {
    "question": "В чем преимущества ООП языков?",
    "answer": "1.Повторное использование кода(наследование) \n2.Реальное отображение предметной области. Объекты соответствуют реальному миру.",
    "category": "JAVA_CORE"
  },
  {
    "question": "В чем разница между композицией и агрегацией?",
    "answer": "Ассоциация обозначает связь между объектами. \nАгрегация и композиция - это частные случаи ассоциации. Агрегация предполагает, что объекты связаны взаимоотношением \"part-of\" (часть). \nКомпозиция - более строгий вариант агрегации. Дополнительно к требованию part-of накладывается условие, что \"часть\" не может одновременно принадлежать разным \"хозяевам\", и заканчивает своё существование вместе с владельцем.",
    "category": "JAVA_CORE"
  },
  {
    "question": "В чем разница между статическим и динамическим связыванием?",
    "answer": "Разница состоит в том, что первое происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения, с использованием конкретных объектов. Лучший пример статического связывания – перегрузка методов, а переопределение – динамического.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Чем отличается JRE, JVM и JDK?",
    "answer": "JRE - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Состоит из виртуальной машины и библиотеки Java-классов. \nJDK - это комплект разработчика приложений на Java, включающий в себя компилятор Java (javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему Java (JRE). \nJVM - виртуальная машина Java - основная часть исполняющей системы Java (JRE). Она интерпретирует байт-код, предварительно созданный из исходного текста Java-программы компилятором Java (javac).",
    "category": "JAVA_CORE"
  },
  {
    "question": "Опишите модификаторы доступа в Java.",
    "answer": "1.private: (используется конструкторах, внутренних классах, методах и полях класса) - Доступ разрешен только в текущем классе. \n2.default (package-private): (используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - Доступ на уровне пакета. \n3.protected: (используется конструкторах, внутренних классах, методах и полях класса) Модификатор доступа на уровне пакета и в иерархии наследования. \n4.public: (используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - Модификатор доступа общественный, доступен всем.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое package level access?",
    "answer": "Доступ из классов одного package-а в классы другого package-a.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Чем абстрактный клас отличается от интерфейса? В каких случаях Вы бы использовали абстрактный класс, а в каких интерфейс?",
    "answer": "Абстрактный класс это класс, который помечен как \"abstract\", он может содержать абстрактные методы. Экземпляр абстрактного класса нельзя создать. Класс, который наследуется от абстрактного класса может реализовывать абстрактные методы, а может и не реализовывать, тогда класс наследник должен быть тоже абстрактным. Также если класс наследник переопределяет реализованный в абстрактном классе родители метод, его можно переопределить с модификатором абстракт! Т.е отказаться от реализации. Соответственно данный класс должен быть также абстрактным также. \nЧто касается интерфейса, то в нем находятся стандартные методы (default methods), статические методы (static methods), абстрактные методы и константы. Default метод в интерфейсе - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса. Static методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе. При реализации интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс должен быть помечен как абстрактный. Интерфейс также может содержать внутренние классы. И не абстрактные методы в них. \nАбстрактный класс используется когда нам нужна какая-то реализация по умолчанию. \nИнтерфейс используется когда классу нужно указать конкретное поведение. \nЧасто интерфейс и абстрактный класс комбинируют, т.е. имплементируют интерфейс в абстрактном классе, чтоб указать поведение и реализацию по умолчанию.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Может ли объект получить доступ к private-переменной класса?",
    "answer": "Вообще доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к приватным переменным можно осуществить через механизм Java Reflection API.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего в джаве статические блоки?",
    "answer": "Статические блоки в джава выполняются до выполнения конструктора, с помощью них инициализируют статические поля к примеру. Блок статической инициализации может создаваться сам при компиляции программы.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Можно ли перегрузить static метод?",
    "answer": "Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот в переопределении статического метода смысла нет.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Расскажите про внутренние классы. Когда вы их будете использовать?",
    "answer": "Внутренний класс - это класс, который находится внутри класса или интерфейса. При этом он получает доступ ко всем полям и методам своего внешнего класса. Для чего он может применятся? Например чтоб обеспечить какую-то дополнительную логику класса. Хотя использование внутренних классов усложняет программу, рекомендуется избегать их использование.",
    "category": "JAVA_CORE"
  },
  {
    "question": "В чем разница между переменной экземпляра и статической переменной?",
    "answer": "Статические переменные инициализируются при загрузке класса класслодером, и не зависят от объекта. Переменная экземпляра инициализируется при создании класса.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Расскажите про классы - загрузчики и про динамическую зарузку классов.",
    "answer": "Любой класс, используемый в джава программе так или иначе был загружен в контекст каким-то загрузчиком. Все виртуальные машины джава включают хотябы один загрузчик классов, так называем базовый загрузчик. Он загружает все основные классы, это классы из rt.jar. Интересно то, что этот загрузчик никак не связан с программой, тоесть мы не можем получить например у java.lang.Object имя зарузчика, метод getClassLoader() вернет нам null. \nСледующий загрузчик - это загрузчик расширений, он загружает классы из $JAVA_HOME/lib/ext. \nДалее по иерархии идет системный загрузчик, он загружает классы, путь к которым указан в переменной класпас. Если в системе присутствуют пользовательские загрузики, то они должны быть унаследованы от класса java.lang.ClassLoader. \nСтатическая загрузка класса происходит при использовании оператора \"new\". \nДинамическая загрузка происходит \"на лету\" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). \nДля чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен оператор \"assert\" в джава?",
    "answer": "Это так называемый оператор утверждений. Он проверяет некое условие, если оно ложно, то генерируется AssertionError",
    "category": "JAVA_CORE"
  },
  {
    "question": "Почему в некоторых интерфейсах вообще не определяют методов?",
    "answer": "Это так называемые интерфейсы - маркеры. Они просто указывают что класс относится к определенной группе классов. Например интерфейс Cloneable указывает на то, что класс поддерживает механизм клонирования. Степень абстракции в данном случае доведен до абсолюта. В интерфейсе вообще нет никаких объявлений.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какая основная разница между String, StringBuffer, StringBuilder?",
    "answer": "String - неизменяемый класс, тоесть для для добавление данных в уже существующую строку, создается новый объект строки. \nStringBuffer и StringBuilder могут изменятся и добавление строки не такое дорогостоющее с точки зрения памяти. \nПервый - синхронизированный, второй - нет. Это их единственное различие. Правда если нам нужно сделать подстроку строки, то лучше использовать String, так как ее массив символов не меняется и не создается заново для новой строки. А вот в StringBuffer и StringBuilder для создания подстроки создается новый массив символов.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Расскажите про потоки ввода-вывода Java.",
    "answer": "Потоки ввода-вывода бывают двух видов: байтовый поток(InputStream и OutputStream) и символный поток(Reader и Writer). \nЭто все абстрактные классы - декораторы, которым можно добавлять дополнительный функционал, например: InputStream in = new FileInputStream(new File(\"file.txt\")).",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Heap и Stack память в Java?",
    "answer": "Java Heap (куча) - динамически распредляемая область памяти, создаваемая при старте JVM. Используется Java Runtime для выделения памяти под объекты и JRE классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем удаления объектов, на которые нет каких-либо ссылок. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться с любой части приложения. \nСтековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе расположение в RAM и достижение процессору через указатель стека. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Расскажите про модель памяти в джава?",
    "answer": "В Джаве память устроена следующим образом, есть два вида: куча и стек. Куча состоит из статического контекста и самой кучи. \nСама куча состоит из двух частей: новая и старая куча. Новая куча состоит из Eden и Survival. \nEden Space (heap) - в этой области выделятся память под все создаваемые из программы объекты. Большая часть объектов живет недолго (итераторы, временные объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок мусора это области памяти, не перемещаются в другие области памяти. Когда данная область заполняется (т.е. количество выделенной памяти в этой области превышает некоторый заданный процент), GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора она занимает мало времени, и затрагивает только эту область памяти - очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область. \nSurvivor Space (heap) - сюда перемещаются объекты из предыдущей, после того, как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты из этой области перемещаются в Tenured Space. Tenured (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.). Когда заполняется эта область, выполняется полная сборка мусора (full, major collection), которая обрабатывает все созданные JVM объекты. \nPermanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.).",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как работает сборщик мусора?",
    "answer": "У сборщика мусора есть несколько алгоритмов работы. Если память в Первой куче полностью заполнена, то туда идет сборщик мусора и делает свою работу) Какую именно, зависит от обстоятельств. Например если в первой кучи много мусора(т.е. объектов с нулевой ссылкой), то сборщик мусора помечает эти объекты, далее те что остались объекты со ссылками он их переносит в Выжившую кучу, а в первой куче он просто все удаляет. \nСитуация другая, в первой кучи мало мусора, но очень много рабочих объектов. Он помечает мусор, удаляет его и оставшиеся объекты компонует. \nТакже следует заметить что при нехватке места в Выжившей куче, объекты переносятся в старую кучу, там хранятся как правило долго живущие объекты. \nСборщик мусора вызывается сам периодически, а не только когда памяти не хватает.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Расскажите про приведение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?",
    "answer": "Приведение типов это установка типа переменной или объекта отличного от текущего. В java есть два вида приведения: автоматическое и явное. Если же мы сужаем, то необходимо явно указывать приведение типа. В случае же с объектами, то мы можем сделать автоматическое приведение от наследника к родителю, но никак не наоборот, тогда вылетит ClassCastException.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое статический класс, какие особенности его использования?",
    "answer": "Статическим классом может быть только внутренний клас(определение класса размещается внутри другого класса). В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического внутреннего класса такой ссылки нет. То есть: Для создания объекта статического внутреннего класса не нужен объект внешнего класса. Из объекта статического вложенного класса нельзя обращаться к нестатическим членам внешнего класса напрямую. И еще обычные внутренние классы не могут содержать статические методы и члены.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Каким образом из вложенного класса получить доступ к полю внешнего класса?",
    "answer": "Если класс внутренний то: Внешнийкласс.this.Поле внешнего класса. Если класс статический внутренний(вложенный),то в методе нужно создать объект внешнего класса, и получить доступ к его полю. Или второй вариант объявить это поле внешнего класса как static",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие существуют типы вложенных классов? Для чего они используются?",
    "answer": "Вложенные классы существуют внутри других классов. \nНормальный класс - полноценный член пакета. Вложенные классы, которые стали доступны начиная с Java 1.1, могут быть четырех типов: статические члены класса, члены класса, локальные классы, анонимные классы. \nСтатические члены классов (static nested classes) - как и любой другой статический метод, имеет доступ к любым статическим методам своего внешнего класса, в том числе и к приватным. К нестатическим полям и методам обрамляющего класса он не может обращатся напрямую. Он может использовать их только через ссылку на экземпляр класса родителя. \nЧлены класса - локальные классы, объявленные внутри блока кода. Эти классы видны только внутри блока. \nАнонимные классы - эти типы классов не имеют имени и видны только внутри блока.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Возможно ли при переопределении (override) метода изменить: 1.Модификатор доступа 2.Возвращаемый тип 3.Тип аргумента или количество 4.Имя аргументов 5.Изменять порядок, количество или вовсе убрать секцию throws?",
    "answer": "1.Да, если расширять (package -> protected -> public) \n2.Да, если выполняется Downcasting(понижающее преобразование, преобразование вниз по иерархии) то есть возвращаемый тип в переопределенном методе класса наследника должен быть НЕ шире чем в классе родителе (Object -> Number -> Integer) \n3.Нет, в таком случае происходит Overload(перегрузка) \n4.Да 5.Возможно изменять порядок. Возможно вовсе убрать секцию throws в методе, так как она уже определена. Так же возможно добавлять новые исключения, которые наследуются от объявленных или исключения времени выполнения. \nМетод обьявленный как \"private\" в классе родителе нельзя переопределить!",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое autoboxing?",
    "answer": "Autoboxing/Unboxing - автоматическое преобразование между скалярными типами Java и соответствующими типами-врапперами (например, между int - Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Generics?",
    "answer": "\"Java Generics\" - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Каким образом передаются переменные в методы, по значению или по ссылке?",
    "answer": "В java параметры в методы передаются по значению, тоесть создаются копии параметров и с ними ведется работа в методе. \nВ случае с примитивными типами, то при передачи параметра сама переменная не будет меняться так как в метод просто копируется ее значение. \nА вот при передачи объекта копируется ссылка на объект, тоесть если в методе мы поменяем состояние объекта, то и за методом состояние объекта тоже поменяется. Но если мы этой копии ссылки попытаемся присвоить новую ссылку на обьект, то старая ссылка у нас не изменится. \nВ случае передачи по значению параметр копируется. Изменение параметра не будет заметно на вызывающей стороне. В Java объекты всегда передаются по ссылке, а примитивы - по значению.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие методы есть у класса Object?",
    "answer": "Object это базовый класс для всех остальных объектов в Java. Каждый класс наследуется от Object. Соответственно все классы наследуют методы класса Object. \nМетоды класса Object: getClass(), hashCode(), equals(Object obj), clone(), toString(), notify(), notifyAll(), wait(), finalize()",
    "category": "JAVA_CORE"
  },
  {
    "question": "Правила переопределения метода Object.equals()?",
    "answer": "Используйте оператор == что бы проверить ссылку на объект, переданную в метод equals. Если ссылки совпадают - вернуть true. Это не обязательно, нужно скорее для оптимизации, но может сэкономить время в случае \"тяжёлых\" сравнений. \nИспользуйте оператор instanceof для проверки типа аргумента. Если типы не совпадают, вернуть false. \nПреобразуйте аргумент к корректному типу. Так как на предыдущем шаге мы выполнили проверку, преобразование корректно. \nПройтись по всем значимым полям объектов и сравнить их друг с другом. Если все поля равны - вернуть true. Для сравнения простых типов использовать ==. Для полей со ссылкой на объекты использовать equals. float преобразовывать в int с помощью Float.floatToIntBits и сравнить с помощью ==. double преобразовывать в long с помощью Double.doubleToLongBits и сравнить с помощью ==. \nДля коллекций вышеперечисленные правила применяются к каждому элементу коллекции. Нужно учитывать возможность null полей/объектов. \nОчерёдность сравнения полей может существенно влиять на производительность. \nЗакончив реализацию equals задайте себе вопрос, является ли метод симметричным, транзитивным и непротиворечивым. Переопределив equals, всегда переопределять hashCode. Не использовать сложную семантику в equals (типа определения синонимов). equals должен сравнивать поля объектов, не более.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?",
    "answer": "Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным. \nРефлексивность: для любого ненулевого x, x.equals(x) вернет true; \nТранзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true; \nСимметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true. \nТакже для любого ненулевого x, x.equals(null) должно вернуть false.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какая связь между hashCode и equals?",
    "answer": "Объекты равны, когда a.equals(b)=true и a.hashCode==b.hashcode -> true Но необязательно, чтобы два различных объекта возвращали различные хэш коды(такая ситуация называется коллизией).",
    "category": "JAVA_CORE"
  },
  {
    "question": "Каким образом реализованы методы hashCode и equals в классе Object?",
    "answer": "Реализация метода equals в классе Object сводится к проверке на равенство двух ссылок. Реализация же метода hashCode класса Object сделана нативной, т.е. определенной не с помощью Java-кода. Он обычно возвращает адрес объекта в памяти.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?",
    "answer": "Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как HashMap, HashSet. \nНапример HashSet хранит элементы в случайном (на первый взгляд) порядке. Дело в том, что для быстрого поиска HashSet расчитывает для каждлого элемента hashCode и именно по этому ключу ищет и упорядочивает элементы внутри себя.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?",
    "answer": "Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid, например. Причем, если эти поля задействованы при вычислении hashCode, то нужно их задействовать при выполнении equals.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен метод hashCode()?",
    "answer": "Существуют коллекции(HashMap, HashSet), которые используют хэш код, как основу при работе с объектами. А если хэш для равных объектов будет разным, то в HashMap будут два равных значения, что является ошибкой. Поэтому необходимо соответствующим образом переопределить метод hashCode(). \nХеширование - преобразование входного массива данных произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свёртки, а их результаты называют хешем или хеш-кодом. \nХеш-таблица - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. \nВыполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива H[i]. Одним из методов построения хеш-функции есть метод деления с остатком (division method) состоит в том, что ключу k ставится в соответствие остаток от деления k на m, где m - число возможных хеш-значений.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Правила переопределения метода Object.hashCode().",
    "answer": "При реализации hashCode используется несколько простых правил. Прежде всего, при вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для равных обектов, во-вторых, распределено полученное значение будет точно так же, как и исходные данные. Теоретически, можно сделать так, чтобы хеш-код всегда был равен 0, и это будет абсолютно легальная реализация. Другое дело, что ее ценность будет равна тому же самому нулю. Далее. Несмотря на то, что хеш-коды равных объектов должны быть равны, обратное неверно! Два неравных объекта могут иметь равные хеш-коды. Решающее значение имеет не уникальность, а скорость вычисления, потому как это приходится делать очень часто. Потому, в некоторых случаях имеет смысл посчитать хеш-код заранее и просто выдавать его по запросу. Прежде всего это стоит делать тогда, когда вычисление трудоемко, а объект неизменен.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Расскажите про клонирование объектов. В чем отличие между поверхностным и глубоким клонированием?",
    "answer": "Чтобы объект можно было клонировать, он должен реализовать интерфейс Cloneable(маркер). Использование этого интерфейса влияет на поведение метода \"clone\" класс Object. Таким образом myObj.clone() создаст нам клон нашего объекта, но этот клон будет поверхностный. Что значит поверхностным? Это значит что клонируется только примитивные поля класса, ссылочные поля не клонируются! Для того, чтоб произвести глубокое клонирование, необходимо в клонируемом классе переопределить метод clone() и в нем произвести клонирование изменяемых полей объекта.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Правила переопределения метода Object.clone().",
    "answer": "Метод clone() в Java используется для клонирования объектов. Т.к. Java работает с объектами с помощью ссылок, то простым присваиванием тут не обойдешься, ибо в таком случае копируется лишь адрес, и мы получим две ссылки на один и тот же объект, а это не то, что нам нужно. \nМеханизм копирования обеспечивает метод clone() класса Object. clone() действует как конструктор копирования. Обычно он вызывает метод clone() суперкласса и т.д. пока не дойдет до Object.Метод clone() класса Object создает и возвращает копию объекта с такими же значениями полей. Object.clone() кидает исключение CloneNotSupportedException если вы пытаетесь клонировать объект не реализующий интерфейс Cloneable. \nРеализация по умолчанию метода Object.clone() выполняет неполное/поверхностное (shallow) копирование. Если вам нужно полное/глубокое (deep) копирование класса то в методе clone() этого класса, после получения клона суперкласса, необходимо скопировать нужные поля. \nМетод clone() несовместим с final полями. Если вы попробуете клонировать final поле компилятор остановит вас. Единственное решение - отказаться от final.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Где и как вы можете использовать закрытый конструктор?",
    "answer": "Например в качестве паттерна Синглетон. В том же классе создается статический метод. Где и создается экземпляр класса, конечно если он уже не создан, тогда он просто возвращается методом.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое конструктор по умолчанию?",
    "answer": "В Java если нет явным образом опредёленных конструкторов в классе, то компилятор использует конструктор по умолчанию, опредёленный неявным способом, который аналогичен \"чистому\", конструктору по умолчанию. Конструктор по умолчанию - это довольно простая конструкция, которая сводится к созданию для типа конструктора без параметров. \nТак, например, если при объявлении нестатического класса не объявить пользовательский конструктор (не важно, с параметрами или без них), то компилятор самостоятельно сгенерирует конструктор без параметров. В Java если производный класс не вызывает явным образом конструктор базового класса (в Java используя super() в первой строчке), то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет конструктора по умолчанию, то это считается ошибкой.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Опишите метод Object.finalize().",
    "answer": "Метод finalize(). Java обеспечивает механизм, который является аналогичным использованию деструкторов в С ++, который может использоваться для того, чтобы произвести процесс очистки перед возвращением управления операционной системе. \nПрименяя метод finalize(), можно определять специальные действия, которые будут выполняться тогда, когда объект будет использоваться сборщиком мусора. \nДанный метод вызывается при уничтожении объекта автоматическим сборщиком мусора (garbage collector). В классе Object он ничего не делает, однако в классе-наследнике позволяет описать все действия, необходимые для корректного удаления объекта, такие как закрытие соединений с БД, сетевых соединений, снятие блокировок на файлы и т.д. \nВ обычном режиме напрямую этот метод вызывать не нужно, он отработает автоматически. Если необходимо, можно обратиться к нему явным образом.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Чем отличаются слова final, finally и finalize?",
    "answer": "final - Нельзя наследоваться от файнал класса. Нельзя переопределить файнал метод. Нельзя изменить сначение файнал поля. \nfinally - используется при обработке ошибок, вызывается всегда, даже если произошла ошибка(кроме System.exit(0)). Удобно использовать для освобождения ресурсов. \nfinalize() - вызывается перед тем как сборщик мусора будет проводить освобождение памяти. Не рекомендуется использовать для освобождения системных ресурсов, так как не известно когда сборщик мусора будет производить свою очистку. Вообще данный метод мало кто использует. Единственно что можно использовать этот метод для закрытия ресурса что должен работать на протяжении всей работы программы и закрываться по ее окончанию. Еще можно использовать метод для защиты от так называемых дураков, проверять, освобождены ли ресурсы, если нет, то закрыть их.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Опишите иерархию исключений.",
    "answer": "Все классы-исключения расширяют класс Throwable - непосредственное расширение класса object. У класса Throwable два непосредственных наследника - классы Error и Exception. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства - семейство классов-ошибок (error) и семейство собственно классов-исключений (exception). \nКлассы-ошибки, расширяющие класс Error, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором throw. He следует делать свои классы-исключения расширениями класса Error или какого-то его подкласса. Имена классов-ошибок, по соглашению, заканчиваются словом Error. \nКлассы-исключения, расширяющие класс Exception, отмечают возникновение обычной нештатной ситуации, которую нужно обработать. Такие исключения следует выбросить оператором throw. \nКлассов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс Exception или любой его подкласс. \nСреди классов-исключений выделяется класс RuntimeException - прямое расширение класса Exception. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой throws.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие виды исключений в Java вы знаете, чем они отличаются?",
    "answer": "Все исключительные ситуации можно разделить на две категории: проверяемые(checked) и непроверяемые(unchecked). Все исключения, порождаемые от Throwable, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками Throwable - классами Error и Exception, а также наследником Exception - RuntimeException. \nОшибки, порожденные от Exception (и не являющиеся наследниками RuntimeException ), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях. \nИсключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки. Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, IndexOutOfBoundsException- выход за границы массива, java.lang.ArithmeticException- деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch. \nИсключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти). \nМетоды, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется. Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое checked и unchecked Exception?",
    "answer": "Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. \nUnchecked могут не обрабатываться и не быть описанными. \nUnchecked исключения в Java - наследованные от RuntimeException, Checked - от Exception. Пример unchecked исключения - NullPointerException, checked исключения - IOException.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как создать свой unchecked Exception?",
    "answer": "Унаследоваться от RuntimeException.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Error?",
    "answer": "Исключения, порожденные от Error, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти). \nМетоды, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Опишите работу блока try-catch-finally.",
    "answer": "Если срабатывает один из блоков catch, то остальные блоки в данной конструкции try-catch выполняться не будут. \nСвойством транзакционности исключения не обладают - действия, произведенные в блоке try до возникновения исключения, не отменяются после его возникновения.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Возможно ли использование блока try-finally (без catch)?",
    "answer": "try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally. Это может быть полезно, например, в следующей ситуации. При выходе из метода вам надо произвести какое-либо действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым return нецелесообразно. Гораздо проще и эффективнее поместить основной код в try, а код, выполняемый при выходе - в finally.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Всегда ли исполняется блок finally?",
    "answer": "Не всегда например в следующих ситуациях: \n1.Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью. Таким образом, когда все потоки не демоны завершаются, программа завершает свою работу. В потоках демонах блок finally не выполняеться, они прерываются внезапно. \n2.System.exit(0). \n3.Если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие есть оссобенности класса String? Что делает метод intern()?",
    "answer": "Внутреннее состояние класса String нельзя изменить после его создания, т.е. этот класс неизменяемый (immutable) поэтому когда вы пишете String str = \"One\" + \"Two\"; создается три! объекта класса String. От него нельзя унаследоваться, потому что класс String объявлен как final: public final class String. Метод hashCode класса String переписан и возвращает: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. У класса String есть метод public String intern(), который возвращает строку в каноническом ее представлении из внутреннего пула строк, поддерживаемого JVM. Он нужен чтобы вместо String.equals() использовать ==.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Можно ли наследовать строковый тип, почему?",
    "answer": "Классы объявлены final, поэтому наследоваться не получится.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Дайте определение понятию конкатенация строк.",
    "answer": "Конкатенация - операция объединения строк. Результатом является объединения второй строки с окончанием первой.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как перевернуть строку?",
    "answer": "Использовать метод reverse() StringBuilder",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как сравнить значение двух строк?",
    "answer": "Строка в Java - это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Оператор == (а также !=) работает с ссылками объекта String. Если две переменные String указывают на один и тот же объект в памяти, сравнение вернет результат true. В противном случае результат будет false, несмотря на то что текст может содержать в точности такие же символы. Для сравнения посимвольно на эквивалентность необходимо использовать метод equals().",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как обрезать пробелы в начале и конце строки?",
    "answer": "Использовать метод trim()",
    "category": "JAVA_CORE"
  },
  {
    "question": "Дайте определение понятию \"пул строк\".",
    "answer": "Пул строк - это набор строк, который хранится в памяти Java heap. \nМы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках. Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. \nПул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени. \nКогда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. \nТем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Можно ли синхронизировать доступ к строке?",
    "answer": "String сам по себе потокобезопасный класс. Если мы работаем с изменяемыми строками, то нужно использовать StringBuffer.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?",
    "answer": "Привести их к одному типу и сравнить.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Почему строка неизменная и финализированная в Java?",
    "answer": "Есть несколько преимуществ в неизменности строк: \n1.Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку. \n2.Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения. \n3.Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных. \n4.Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое рефлексия?",
    "answer": "Рефлексия используется для получения или модификации информации о типах во время выполнения программы. Этот механизм позволяет получить сведения о классах, интерфейсах, полях, методах, конструкторах во время исполнения программы. При этом не нужно знать имена классов, методов или интерфейсов. Также этот механизм позволяет создавать новые объекты, выполнять методы и получать и устанавливать значения полей.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что произойдет со сборщиком мусора (GC), если во время выполнения метода finalize() некоторого объекта произойдет исключение?",
    "answer": "Во время старта JVM запускается поток finalizer, который работает в фоне. Этот поток имеет метод runFinalizer, который игнорирует все исключения методов finalize объектов перед сборкой мусора. То есть если во время выполнения метода finalize возникнет исключительная ситуация, его выполнение будет остановлено и это никак не скажется на работоспособности самого сборщика мусора (garbage collector).",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Аннотации в Java?",
    "answer": "Аннотации - это своего рода метатеги, которые добавляются к коду и применяются к объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных переменных. \nАннотации всегда обладают некоторой информацией и связывают эти \"дополнительные данные\" и все перечисленные конструкции языка. Фактически аннотации представляют собой их дополнительные модификаторы, применение которых не влечет за собой изменений ранее созданного кода.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие функции выполняет Аннотации?",
    "answer": "Аннотация выполняет следующие функции: \n1.дает необходимую информацию для компилятора; \n2.дает информацию различным инструментам для генерации другого кода, конфигураций и т. д.; \n3.может использоваться во время работы кода;",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие встроенные аннотации в Java вы знаете?",
    "answer": "В языке Java SE определено несколько встроенных аннотаций, большинство из их являются специализированными. Четыре типа @Retention, @Documented, @Target и @Inherited - из пакета java.lang.annotation. Из оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и @SuppressWarnings - из пакета java.lang. Широкое использование аннотаций в различных технологиях и фреймворках обуславливается возможностью сокращения кода и снижения его связанности.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какой жизненный цикл аннотации можно указать с помощью @Retention?",
    "answer": "Существует 3 возможные варианты чтобы указать где аннотация будет жить. Они инкапсулированы в перечисление java.lang.annotation.RetentionPolicy. Это SOURSE, CLASS, RUNTIME. \n1.SOURCE - содержаться только в исходном файле и отбрасываются при компиляции. \n2.CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения. \n3.RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Как создать свою Аннотацию?",
    "answer": "Структура практически та же, что и у интерфейсов, только пишется @interface.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие механизмы обеспечивают безопасность в технологии Java?",
    "answer": "1.структурные функциональные возможности языка (например, проверка границ массивов, запрет на преобразования непроверенных типов, отсутствие указателей и т.д.). \n2.средства контроля доступа, определяющие действия, которые разрешается или запрещается выполнять в коде (например, может ли код получать доступ к файлам, передавать данные по сети и т.д.). \n3.механизм цифровой подписи, предоставляющий авторам возможность применять стандартные алгоритмы для аутентификации своих программ, а пользователям - точно определять, кто создал код и изменился ли он с момента его подписания.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Назовите несколько видов проверок которые выполняет верификатор байт-кода Java?",
    "answer": "1.инициализация переменных перед их использованием. \n2.согласование типов ссылок при вызове метода. \n3.соблюдение правил доступа к закрытым данным и методам. \n4.доступ к локальным переменным в стеке во время выполнения. \n5.отсутствие переполнения стека... \nПри невыполнении какой-нибудь из этих проверок класс считается поврежденным и загружаться не будет.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что вы знаете о \"диспетчере защиты\" в Java?",
    "answer": "В качестве диспетчера защиты служит класс, определяющий, разрешено ли коду выполнять ту или иную операцию: \n1.создание нового загрузчика классов. \n2. выход из виртуальной машины. \n3.получение доступа к члену другого класса с помощью рефлексии. \n4.получение доступа к файлу. \n5.установление соединения через сокет. \n6.запуск задания на печать. \n7.получение доступа к системному буферу обмена. \n8.получение доступа к очереди событий в AWT. \n9.обращение к окну верхнего уровня.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Рефакторинг?",
    "answer": "Рефакторинг - процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какова структура лямбда-выражения?",
    "answer": "Лямбда выражение имеет следующую структуру: \n(method params) -> {lambda expression body} где \nmethod params - список входящих параметров, разделенных запятой(в случаи если параметров больше одного заключаются в скобки) \nоператор -> - служит разделителем между списком параметров нашего метода и телом, в котором происходит его реализация.\nlambda expression body - тело метода, состоящее из одного выражения или нескольких, заключенных в фигурные скобки.",
    "category": "JAVA_CORE"
  },
  {
    "question": "К каким переменным есть доступ у Лямбда-выражений?",
    "answer": "Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили. Но доступ возможен только при условии, что переменные являются effective final, то есть либо явно имеют модификатор final, либо не меняют своего значения после инициализации, если переменной присваивается значение во второй раз, лямбда-выражение вызывает ошибку компиляции.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое ссылки на метод?",
    "answer": "Ссылки на метод - компактные лямбда-выражения которые позволяют передавать ссылки на методы или конструкторы. Для этого нужно использовать ключевое слово \"::\". \nСсылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов (экземпляров). Совместно с лямбда-выражениями, ссылочные методы делают языковые конструкции компактными и лаконичными, делая его шаблонным.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какие виды ссылок на методы вы знаете?",
    "answer": "Существует четыре вида ссылок на методы: \n1.Ссылка на статический метод(ContainingClass::staticMethodName) \n2.Ссылка на метод конкретного объекта(ContainingObject::instanceMethodName) \n3.Ссылка на метод произвольного объекта конкретного типа(ContainingType::methodName) \n4.Ссылка на конструктор(ClassName::new), для дженериков (generics) Class<T>::new.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое функциональные интерфейсы?",
    "answer": "Функциональный интерфейс - это тот интерфейс, который определяет строго один абстрактный метод. \nВ Java 8 была введена новая аннотация @FunctionalInterface для обозначения интерфейса, функциональным, эта аннотация используется для того, чтобы избежать случайного добавления абстрактных методов в функциональный интерфейс. Она не обязательна, но является хорошей практикой написания кода. \nФункциональные интерфейсы позволяют нам использовать лямбда-выражения для создания экземпляра таких интерфейсов. \nЛучшим примером функционального интерфейса будет интерфейс java.lang.Runnable с одним абстрактным методом run(). Заметим, интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default методы - не абстрактные.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен функциональный интерфейс Function<T,R>?",
    "answer": "Представляет собой функцию перехода от объекта типа T к объекту типа R.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен функциональный интерфейс Predicate<T>?",
    "answer": "Представляет собой предикат (булеву функцию) одного аргумента.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен функциональный интерфейс Supplier<T>?",
    "answer": "Представляет собой поставщика результатов.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен функциональный интерфейс Consumer<T>?",
    "answer": "Представляет собой операцию, которая принимает один входной аргумент, выполняет некоторое действие над объектом типа T, при этом ничего не возвращая.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое default методы?",
    "answer": "Начиная с Java 8 мы можем использовать в интерфейсах стандартные методы (default methods) и статические методы (static methods). \nDefault метод - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое static методы?",
    "answer": "Static-методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе. \n1.Статические методы в интерфейсе являются частью интерфейса, мы не можем использовать его для объектов класса реализации. \n2.Статические методы в интерфейсе хороши для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д. \n3.Статические методы в интерфейсе помогают обеспечивать безопасность, не позволяя классам, которые реализуют интерфейс, переопределить их. \n3.Мы не можем определить статические методы для методов класса Object, потому что получим ошибку компиляции.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое потоки(stream) в Java 8?",
    "answer": "java.util.stream - введен для поддержки распараллеливания вычислений в потоках. Предоставляет возможность обрабатывать последовательность элементов исполняя одну или несколько операций, которые могут выполняться либо последовательно либо паралельно. Потоки делятся на последовательные и параллельные. Самая большая польза от этого - в работе с коллекциями. \nОперации над потоком относятся либо к промежуточным, либо к терминальным. Все промежуточные операции возвращают поток, так что мы можем объединять несколько промежуточных операций без использования точки с запятой. Терминальные операции возвращают void или непотоковый результат.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего нужен метод collect Java 8?",
    "answer": "Большинство операций класса Stream, которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, ArrayList или HashSet. И для этого у класса Stream определен метод collect. Метод принимает в качестве параметра функцию преобразования к коллекции. \nВ итоге параметр collector представляет функцию преобразования потока в коллекцию.",
    "category": "JAVA_CORE"
  },
  {
    "question": "В чем разница между коллекцией(Collection) и потоком(Stream)?",
    "answer": "Разница между коллекцией(Collection) данных и потоком(Stream) в том что коллекции позволяют работать с элементами по-отдельности, тогда как поток(Stream) не позволяет. Например, с использованием коллекций, вы можете добавлять элементы, удалять, и вставлять в середину. Поток(Stream) не позволяет манипулировать отдельными элементами из набора данных, но вместо этого позволяет выполнять функции над данными как одним целом.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего предназначен метод forEach в потоках(stream)?",
    "answer": "Метод void forEach(Consumer<? super T> action) - для каждого элемента выполняется действие action. forEach является терминальной операцией, используется для перебора каждого элемента потока. forEach не гарантирует последовательности вывода элементов в параллельном stream-е, для этого используется метод forEachOrdered - он это гарантирует.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего предназначен метод map в потоках(stream)?",
    "answer": "Он преобразует элементы типа T в элементы типа R и возвращает поток с элементами R. map является промежуточной операцией, метод используется для преобразования элементов в другой объект при помощи переданной функции.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Какова цель метода filter в потоках(stream)?",
    "answer": "Он фильтрует элементы в соответствии с условием в предикате. filter является промежуточной операцией, используется для фильтрации массива через функцию. \nНа самом деле filter, не выполняет фильтрацию, вместо этого он создается новый поток, который по завершению формирования, содержит элементы исходного потока, которые соответствуют заданному предикату.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего предназначен метод limit в потоках(stream)?",
    "answer": "Он оставляет в потоке только maxSize элементов. limit является промежуточной операцией, используется для выборки первых maxSize элементов потока. Этот метод также возвращает модифицированный поток, в котором не более maxSize элементов.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Для чего предназначен метод sorted в потоках(stream)?",
    "answer": "Он возвращает отсортированный поток. sorted является промежуточной операцией, метод используется для сортировки потока используя естественный порядок сравнения его элементов. Существует также второй метод sorted(), принимающий либо экземпляр Comparable, либо соответствующее ему лямбда-выражение.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Параллельная обработка в Java 8?",
    "answer": "Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel. Кроме того, можно также использовать метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. \nВ то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный. \nСледующий фрагмент кода, выводит количество пустых строк с помощью метода parallelStream.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Optional?",
    "answer": "Optional - это контейнер объекта, он может содержать значение или некоторый тип Т, или просто быть null. Он предоставляет много полезных методов избавляющие от добавления повторяющихся if null/notNull проверок, что позволяет нам сфокусироваться на том, что мы хотим сделать. \nМетод isPresent() возвращает true если экземпляр Optional содержит не null значение и false в противном случае. Метод orElseGet() содержит запасной механизм результата, если Optional содержит null, принимая функции для генерации значения по умолчанию. Метод map() преобразует текущее значение Optional и возвращает новый экземпляр Optional. Метод orElse() похож на orElseGet(), но вместо функции он принимает значение по умолчанию.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое LocalDateTime в Java 8?",
    "answer": "LocalDateTime объединяет вместе LocaleDate и LocalTime и содержит дату и время, но без часового пояса в календарной системе ISO-8601. Время хранится с точностью до наносекунды, так что в LocalTime можно хранить, например, величину \"13:45.30.123456789\". Есть множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое абсолютный путь и относительный путь?",
    "answer": "Абсолютный путь - это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей директории. Полный путь всегда начинается с корневого каталога. \nОтносительный путь - это путь по отношению к текущему рабочему каталогу.",
    "category": "JAVA_CORE"
  },
  {
    "question": "Что такое Коллекция?",
    "answer": "Коллекции - это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции: \n1.добавление нового элемента в коллекцию; \n2.удаление элемента из коллекции; \n3.изменение элемента в коллекции.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Назовите основные интерфейсы коллекций и их имплементации.",
    "answer": "Collection расширяет три интерфейса: List, Set, Queue. \n\nList - хранит упорядоченные элементы(могут быть одинаковые); Имеет такие реализации: LinkedList, ArrayList и Vector. \nVector синхронизирован, и по этому в одном потоке, он работает медленней остальных реализаций. \n\nSet - коллекции, которые не содержат повторяющихся элементов. Основные реализации: HashSet, TreeSet, LinkedHashSet. \nTreeSet - упорядочивает элементы по их значениям; \nHashSet - упорядочивает элементы по их хэш ключах, хотя на первый взляд может показаться что элементы хранятся в случайном порядке. \nLinkedHashSet - хранит элементы в порядке их добавления. \n\nQueue - интерфейс для реализации очереди в джава. Основные реализации: LinkedList, PriorityQueue. Очереди работают по принципу FIFO (first in first out). \n\nMap - интерфейс для реализации так называемой карты, где элементы хранятся с их ключами. Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap. \nHashTable - синхронизированна, объявлена уставревшей. \nHashMap - порядок елементов рассчитывается по хэш ключу. \nTreeMap - элементы хранятся в отсортированном порядке. \nLinkedHashMap - элементы хранятся в порядке вставки. \nКлючи в Мар не могут быть одинаковыми! Синхронизировать не синхронизированные коллекции и карты можно посредством класса Collections.synchronizedMap(MyMap)\\ synchronizedList(MyList).",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?",
    "answer": "Отличие заключается в способе хранения данных. ArrayList хранит в виде массива, а LinkedList - в виде списка (двунаправленного). В ArrayList быстрее происходит сортировка, т.к. для ее выполнения данные списка копируются в массив (а копировать из массива ArrayList в массив для сортировки быстрее). При большом числе операций добавления и удаления LinkedList должен быть более удачным выбором, т.к. при этих операциях не приходится перемещать части массива. Если при добавлении в ArrayList превышается его объем, размер массива увеличивается, новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1, поэтому лучше указывать размер при создании или, если он не известен, использовать LinkedList (но это может быть существенно при слишком уж больших объемах данных).",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Чем отличается HashMap от Hashtable?",
    "answer": "Класс HashMap по функционалу очень похож на Hashtable. Главное отличие в том, что методы класса Hashtable синхронизированы, а HashMap - нет. Кроме этого класс HashMap в отличии от Hashtable разрешает использование null в качестве ключей и значений. Наличие синхронизации в Hashtable уменьшает производительность кода, использующего данный класс. Поэтому классы JCF (Java Collections Framework, появившийся в Java 2), в том числе и HashMap, несинхронизированы. Если синхронизация все же нужна, можно использовать методы класса Collections: Collections.synchronizedMap(map), Collections.synchronizedList(list) или Collections.synchronizedSet(set). Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае итерирования по коллекции требуется ручная синхронизация. Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Чем отличается ArrayList от Vector?",
    "answer": "Методы класса Vector синхронизированы, в то время как ArrayList - нет.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как сравниваются елементы коллекций?",
    "answer": "Для сравнения элементов коллекций используется метод equals() и hashcode(). Эти методы унаследованы от класса Object.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Почему Map - это не Collection, в то время как List и Set являются Collection?",
    "answer": "Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар \"ключ\"-\"значение\". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map. Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет элемент по заданному ключу.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Дайте определение понятию \"iterator\".",
    "answer": "Итератор - объект, позволяющий перебирать элементы коллекции. Например foreach реализован с использованием итератора. Одним из ключевых методов интерфейса Collection является метод Iterator iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Что вы знаете об интерфейсе Iterable?",
    "answer": "Все коллекции из java.util реализуют интерфейс Collection, который, в свою очередь, расширяет интерфейс Iterable. В интерфейсе Iterable описан только один метод: \nIterator iterator(). Он возвращает Iterator, т.е. объект, который поочерёдно возвращает все элементы коллекции.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как перебрать все ключи Map учитывая, что Map - это не Iterable?",
    "answer": "Использовать метод keySet(), который возвращает множество ключей.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как перебрать все значения Map учитывая, что Map - это не Iterable?",
    "answer": "Использовать метод values(), который возвращает коллекцию значений.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как перебрать все пары ключ-значение в Map учитывая, что Map - это не Iterable?",
    "answer": "Использовать метод entrySet(), который возвращает множество пар \"ключ\"-\"значение\".",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "В чем проявляется сортированность SortedMap, кроме того, что toString() выводит все по порядку?",
    "answer": "Естественное упорядочивание (natural ordering) отражается при итерации по коллекции ключей или значений хэш-таблицы (возвращаемых методами keySet(), values() и entrySet()).",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Сравните Enumeration и Iterator.",
    "answer": "Оба интерфейса предназначены для обхода коллекций. Интерфейс Iterator был введен несколько позднее в Java Collections Framework и его использование предпочтительнее. Основные различия Iterator по сравнению с Enumeration: \nналичие метода remove() для удаления элемента из коллекции при обходе; \nисправлены имена методов для повышения читаемости кода.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как между собой связаны Iterable и Iterator?",
    "answer": "Интерфейс Iterable имеет только один метод - iterator(), который возвращает итератор коллекции для её обхода.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Сравните Iterator и ListIterator.",
    "answer": "ListIterator расширяет интерфейс Iterator, позволяя клиенту осуществлять обход коллекции в обоих направлениях, изменять коллекцию и получать текущую позицию итератора. При этом важно помнить, что ListIterator не указывает на конкретный элемент, а его текущая позиция располагается между элементами, которые возвращают методы previous() и next(). Таким образом, модификация коллекции осуществляется для последнего элемента, который был возвращен методами previous() и next().",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Что произойдет, если я вызову Iterator.next() не спросив Iterator.hasNext()?",
    "answer": "Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Что произойдет, если я вызову Iterator.next() перед этим 10 раз вызвав Iterator.hasNext()? Я пропущу 9 элементов?",
    "answer": "Нет, hasNext() осуществляет только проверку наличия следующего элемента.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Если у меня есть коллекция и порожденный итератор, изменится ли коллекция, если я вызову iterator.remove()?",
    "answer": "Вызов метода iterator.remove() возможен только после вызова метода iterator.next() хотя бы раз, иначе появится исключение IllegalStateException(). Если iterator.next() был вызван прежде, то iterator.remove() удалит элемент, на который указывает итератор.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Если у меня есть коллекция и порожденный итератор, изменится ли итератор, если я вызову collection.remove()?",
    "answer": "Итератор не изменится, но при следующем вызове его методов возникнет исключение ConcurrentModificationException.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можновзять elementData.length?",
    "answer": "Размер массива elementData представляет собой вместимость (capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. С добавлением новых элементов вместимость автоматически возрастает при необходимости.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "LinkedList - это односвязный, двусвязный или четырехсвязный список?",
    "answer": "Двухсвязный список: каждый элемент LinkedList хранит ссылку на предыдущий и следующий элементы.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Какое худшее время работы метода contain() для элемента, который есть в LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Время поиска элемента в LinkedList линейно пропорционально количеству элементов с списке.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Какое худшее время работы метода contain() для элемента, который есть в ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Время поиска элемента в ArrayList линейно пропорционально количеству элементов с списке.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Какое худшее время работы метода add() для LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Здесь стоит заметить, что добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с помощью addFirst(value) выполняется за время O(1). \nO(N) - будет при добавление элемента в отсортированный список, а также при добавлении элемента с помощью метода add(index, value).",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Какое худшее время работы метода add() для ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Вставка элемента в конец списка осуществляется за время O(1), но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Сколько выделяется элементов в памяти при вызове ArrayList.add()?",
    "answer": "Если в массиве достаточно места для размещения нового элемента, то дополнительное место в памяти не выделяется. Иначе происходит создание нового массива.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Сколько выделяется элементов в памяти при вызове LinkedList.add()?",
    "answer": "Создается один новый экземпляр вложенного класса Node.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Оцените количество памяти на хранение одного примитива типа byte в ArrayList?",
    "answer": "ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?",
    "answer": "Использовать обратный итератор. Для этого в LinkedList есть метод descendingIterator().",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?",
    "answer": "Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Можно ли так реализовать equals(Object that) {return this.hashCode() == that.hashCode()}?",
    "answer": "Строго говоря нельзя, поскольку метод hashCode() не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса Object такой код допустим, т.к. метод hashCode() в классе Object возвращает уникальные значения для разных объектов (вычисления основаны на использовании адреса объекта в памяти).",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Будет ли работать HashMap, если все ключи будут возвращать int hashCode() {return 42;}?",
    "answer": "Да, будет. Но тогда хэш-таблица вырождается в связный список и теряет свои преимущества.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?",
    "answer": "Один новый объект статического вложенного класса Entry<K,V>;",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Как работает HashMap при попытке сохранить в нее два элемента по ключам с одинаковым hashCode, но для которых equals == false?",
    "answer": "По значению hashCode вычисляется индекс ячейки массива, в список которой будет происходить добавление элемента. Перед добавлением осуществляется проверка на наличие уже элементов в этой ячейке. Если элементов нет, то происходит добавление. Если возникает коллизия, то итеративно осуществляется обход списка в поисках элемента с таким же ключом и хэш-кодом. Если такой элемент найден, то его значение перезаписывается, а старое - возвращается. Поскольку в условии сказано, что добавляемые ключи - разные, то второй элемент будет добавлен в начало списка.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "HashMap может выродиться в список даже для ключей с разным hashCode. Как это возможно?",
    "answer": "Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет возвращать одинаковое значение.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Какое худшее время работы метода get(key) для ключа, которого нет в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": ">O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Какое худшее время работы метода get(key) для ключа, который есть в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Аналогичные рассуждения, что и для предыдущего вопроса.",
    "category": "JAVA_COLLECTION"
  },
  {
    "question": "Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).",
    "answer": "int initialCapacity - исходный размер HashMap (количество корзин в хэш-таблице в момент её создания), по умолчанию имеет значение 16. \nfloat loadFactor - коэффициент заполнения HashMap. Равен отношению числа хранимых элементов в таблице к её размеру. loadFactor - является мерой заполнения таблицы элементами.",
    "category": "JAVA_COLLECTION"
  }
]